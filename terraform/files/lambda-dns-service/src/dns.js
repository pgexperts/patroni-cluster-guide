import _ from 'lodash';
import AWS from 'aws-sdk';
import escapeStringRegexp from 'escape-string-regexp';
import prettyFormat from 'pretty-format'

const HOSTED_ZONE_ID = process.env['HOSTED_ZONE_ID'],
      DOMAIN = process.env['DOMAIN'];

let EC2, // Populated in handler
    Route53,
    Region;

exports.handler = function(event, context, callback) {
    console.log('Handling event', event);

    let succeed = (v) => {console.info('âœ…  Execution succeeded', v); callback(null, v); }
    let fail = (exc) => { console.error('ðŸ›‘  Execution failed:', exc); callback(exc); }

    Region = event.region;
    AWS.config.update({ region: Region });
    EC2 = new AWS.EC2({ apiVersion: '2016-11-15' });
    Route53 = new AWS.Route53({ apiVersion: '2013-04-01' });

    run(event).then(succeed, fail);
}

async function run(event) {
    if (_.isEmpty(HOSTED_ZONE_ID)) {
        throw new Error('Environment variable "HOSTED_ZONE_ID" must be set');
    }
    if (_.isEmpty(DOMAIN)) {
        throw new Error('Environment variable "DOMAIN" must be set');
    }

    // Assemble the desired state
    let recordNames;
    if (_.has(event, 'recordNames')) {
        // recordNames specified explicitly
        recordNames = event.recordNames;
    } else {
        // infer recordNames from the EC2 ARNS in the event resources
        let instanceIDs = _.flatMap(event.resources, (arn) => {
            let match = arn.match(/^arn:aws:ec2:[\w-]+:\d+:instance\/(i-.+)$/);
            return _.isEmpty(match) ? [] : match[1];
        });
        recordNames = await getInstanceRecords(instanceIDs);
    }

    let recordValues = await Promise.all(_.map(recordNames, getRecordDestinations));
    let records = _.fromPairs(_.zip(recordNames, recordValues));
    console.log('Desired DNS state', prettyFormat(records));

    // Enforce the desired state
    await updateRecords(records);
}

// Returns a set of DNS record names that the given instance IDs implicate
async function getInstanceRecords(instanceIDs) {
    let ec2Response = await EC2.describeInstances({
        InstanceIds: instanceIDs
    }).promise();
    let instances = _.flatMap(ec2Response.Reservations, (r) => r.Instances);

    let names = _.flatMap(instances, (instance) => {
        let tags = _.fromPairs(_.map(instance.Tags, (tag) => [tag.Key, tag.Value]));
        if (_.has(tags, 'role')) {
            let regionalName = `${tags.role}.${Region}.${DOMAIN}`
            let azName = `${tags.role}.${instance.Placement.AvailabilityZone}.${DOMAIN}`
            return [regionalName, azName];
        }
        return [];
    });

    return _.uniq(names);
}

// Build a list of destinations that should be in the given name
async function getRecordDestinations(name) {
    // The role is the part of the string before the region/AZ part
    // Assumption: AZ's begin with the region name (which appears to be true)
    let regexEscapedRegion = escapeStringRegexp(Region);
    let [, role, az] = name.match(new RegExp(`^(.+)\.(${escapeStringRegexp(Region)}[a-z]*)\.`));
    let region = az;
    if (!az.match(/[a-z]$/)) {
        az = null; // we might have a regional name, (eg. eu-west-1), so we don't know the AZ
    }

    let filters = [{ Name: 'tag:role', Values: [role] }];
    if (!_.isNull(az)) {
        filters.push({ Name: 'availability-zone', Values: [az] });
    }

    let ec2Response = await EC2.describeInstances({
        Filters: filters
    }).promise();
    let instances = _.flatMap(ec2Response.Reservations, (r) => r.Instances);
    instances = _.filter(instances, (i) => i.State.Name === 'running');
    let ips = _.map(instances, (i) => i.PrivateIpAddress);
    return _.sortBy(ips);
}

// Returns whether the change passed would amount to a no-op
async function isNoOpChange(change) {
    // We only care about UPSERTs for this purpose (DELETEs are the only other
    // action type used, and they are generated by direct comparison with
    // actual state)
    if (change.Action !== 'UPSERT') return false;

    const record = change.ResourceRecordSet;
    let listRsp = await Route53.listResourceRecordSets({
        HostedZoneId: HOSTED_ZONE_ID,
        StartRecordType: record.Type,
        StartRecordName: record.Name,
        MaxItems: '1'
    }).promise();

    // If there is an identical record, this is a no-op
    return _.some(listRsp.ResourceRecordSets, (candidate) => {
        return candidate.Type === record.Type &&
               _.trimEnd(candidate.Name, '.') === _.trimEnd(record.Name, '.') &&
               candidate.TTL === record.TTL &&
               _.isEqual(_.sortBy(candidate.ResourceRecords), _.sortBy(record.ResourceRecords));
    });
}

// Returns a set of changes to be made for the {name: destinations} pair passed
async function getChanges(destinations, name) {
    let change;

    if (_.isEmpty(destinations)) {
        let listRsp = await Route53.listResourceRecordSets({
            HostedZoneId: HOSTED_ZONE_ID,
            StartRecordType: 'A',
            StartRecordName: name,
            MaxItems: '1'
        }).promise();
        // The call doesn't necessarily return _matching_ records (just those that "start" where
        // a matching record _would_ exist. Filter to what we actually want.
        let matchedRecord = _.find(listRsp.ResourceRecordSets, (rs) => {
            return rs.Type === 'A' && rs.Name === name
        });

        if (!_.isNil(matchedRecord)) {
            change = {
                Action: 'DELETE',
                ResourceRecordSet: matchedRecord,
            };
        }
    } else {
        change = {
            Action: 'UPSERT',
            ResourceRecordSet: {
                TTL: 5,
                Type: 'A',
                Name: name,
                ResourceRecords: _.map(destinations, (d) => { return { Value: d }; })
            }
        };
    }

    // Determine whether the change is a no-op
    if (_.isNil(change)) return [];
    let isNoOp = await isNoOpChange(change);
    return isNoOp ? [] : [change];
}

async function updateRecords(desiredState) {
    let changes = _.flatten(await Promise.all(_.map(desiredState, getChanges)));
    if (_.isEmpty(changes)) {
        console.log('No changes to be applied');
    } else {
        console.log('Applying Route 53 changes', prettyFormat(changes));
        await Route53.changeResourceRecordSets({
            HostedZoneId: HOSTED_ZONE_ID,
            ChangeBatch: {
                Comment: `Automated update by Lambda function @ ${new Date().toString()}`,
                Changes: changes
            }
        }).promise();
    }
}
